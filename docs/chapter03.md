# 3. ディスクとファイル管理

## ディスク

アクセス高速化

- ディスクキャッシュ
  - セクターのキャッシュを持ち、ディスクアクセスlii同一セクターへのアクセスはキャッシュを使う
  - データベースエンジン側でもキャッシュするのであんまり効果ない
  - 要求されたセクターのトラック全体を事前読み込みしてキャッシュするのは効果あり
- ストライピング
  - 同時に複数のアクセス要求に対応できる
  - 複数の物理ディスクを1つの仮想ディスクとして扱う
  - 仮想ディスクのセクターは交互に別のディスクに向けておいたほうが、lii均等にリクエストが分散して良い

信頼性向上

- ミラーリング
  - ディスク・ドライブは完璧な信頼性があるとはいえないので、書き込み時は複数のディスクに書き込む
  - 2ディスクのミラーからの復旧はフールプルーフではない
    - 要件に応じては3ディスクのミラーを検討
  - ストライピングと共存可能
    - その場合は最小4ディスク=2(ストライピング用)+2(ミラー用)必要
- パリティ
  - ミラーリングを使うと保存容量の2倍のディスクが必要
  - ストライピングも併用するとやばく、現実的ではない
  - パリティを保存するディスクを用意
  - 経験上、書き込み時のストライピング効率が約20%低下

|RAID|ストライピング|ミラーリング|パリティ|備考|
|:--|:--:|:--:|:--:|:--|
|0|セクタ？|-|-||
|1|セクタ？|あり|-||
|2|ビット|-|-|パフォーマンスが微妙でもう使われていない|
|3|バイト|-|パリティ用ディスク必要||
|4|セクタ|-|パリティ用ディスク必要||
|5|セクタ|-|複数ディスクに分散||
|6|セクタ|-|複数ディスクに分散|2ディスク破損でも復旧可能|

## ファイル管理

- 連続アロケーション
  - ファイルを連続ブロックでアロケーション
  - 次のファイルブロックがあった場合にファイルサイズを拡張できない
  - 内部/外部断片化が起きる
- Extent-Based アロケーション
  - ファイルを固定長の extents の連続したまとまりでアロケーション
  - 内部断片化は抑えて、外部断片化は起きない
- インデックスアロケーション
  - ファイルを独立したまとまりでアロケーション
  - OSはファイルごとに特別なインデックスブロックをアロケーション
  - 内部/外部断片化はどちらも起きない
  - インデックスブロックによるファイルサイズ制限がある
    - UNIXは多段インデックスブロックで対処

## データベースシステムが採用するディスクアクアセス

- ブロックレベル
  - デメリット
    - 実装が複雑
    - データベース管理者はブロックアクセスに関する専門知識が必要
- テーブルごとのファイル保存など、可能な限りファイルに保存
  - メリット
    - シンプルな実装
    - データベースシステムからディスクアクセスを隠蔽
  - デメリット
    - データベースシステムがブロック境界を知る必要がある
      - 高効率なデータ取得のため
    - データベースシステムは自身のページを管理する必要がある
      - OSのI/Oバッファ管理がDBクエリには不向き
- すべてのデータをOSの単一または複数のファイルで保存し、「rawディスク」としてファイルを扱う
  - 論理ファイルブロックを使って「rawディスク」にアクセス
  - 多くのデータベースシステムはこちらを採用
